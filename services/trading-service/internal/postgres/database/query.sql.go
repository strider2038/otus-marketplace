// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package database

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
)

const addItem = `-- name: AddItem :one
INSERT INTO "item" (id, name, initial_count, initial_price, commission_percent, created_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, initial_count, initial_price, commission_percent, created_at
`

type AddItemParams struct {
	ID                uuid.UUID
	Name              string
	InitialCount      int32
	InitialPrice      float64
	CommissionPercent float64
	CreatedAt         time.Time
}

func (q *Queries) AddItem(ctx context.Context, arg AddItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, addItem,
		arg.ID,
		arg.Name,
		arg.InitialCount,
		arg.InitialPrice,
		arg.CommissionPercent,
		arg.CreatedAt,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.InitialCount,
		&i.InitialPrice,
		&i.CommissionPercent,
		&i.CreatedAt,
	)
	return i, err
}

const createPurchaseOrder = `-- name: CreatePurchaseOrder :one
INSERT INTO "purchase_order" (id, user_id, item_id, payment_id, deal_id, price, commission, status, created_at,
                              updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, item_id, payment_id, deal_id, price, commission, status, created_at, updated_at
`

type CreatePurchaseOrderParams struct {
	ID         uuid.UUID
	UserID     uuid.UUID
	ItemID     uuid.UUID
	PaymentID  uuid.NullUUID
	DealID     uuid.NullUUID
	Price      float64
	Commission float64
	Status     PurchaseStatus
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

func (q *Queries) CreatePurchaseOrder(ctx context.Context, arg CreatePurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, createPurchaseOrder,
		arg.ID,
		arg.UserID,
		arg.ItemID,
		arg.PaymentID,
		arg.DealID,
		arg.Price,
		arg.Commission,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.PaymentID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSellOrder = `-- name: CreateSellOrder :one
INSERT INTO "sell_order" (id, user_id, item_id, accrual_id, deal_id, price, commission, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, item_id, accrual_id, deal_id, price, commission, status, created_at, updated_at
`

type CreateSellOrderParams struct {
	ID         uuid.UUID
	UserID     uuid.NullUUID
	ItemID     uuid.UUID
	AccrualID  uuid.NullUUID
	DealID     uuid.NullUUID
	Price      float64
	Commission float64
	Status     SellStatus
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

func (q *Queries) CreateSellOrder(ctx context.Context, arg CreateSellOrderParams) (SellOrder, error) {
	row := q.db.QueryRow(ctx, createSellOrder,
		arg.ID,
		arg.UserID,
		arg.ItemID,
		arg.AccrualID,
		arg.DealID,
		arg.Price,
		arg.Commission,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i SellOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.AccrualID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAllItems = `-- name: FindAllItems :many
SELECT id, name, initial_count, initial_price, commission_percent, created_at
FROM "item"
ORDER BY name
`

func (q *Queries) FindAllItems(ctx context.Context) ([]Item, error) {
	rows, err := q.db.Query(ctx, findAllItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.InitialCount,
			&i.InitialPrice,
			&i.CommissionPercent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findItem = `-- name: FindItem :one
SELECT id, name, initial_count, initial_price, commission_percent, created_at
FROM "item"
WHERE id = $1
LIMIT 1
`

func (q *Queries) FindItem(ctx context.Context, id uuid.UUID) (Item, error) {
	row := q.db.QueryRow(ctx, findItem, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.InitialCount,
		&i.InitialPrice,
		&i.CommissionPercent,
		&i.CreatedAt,
	)
	return i, err
}

const findPurchaseOrder = `-- name: FindPurchaseOrder :one
SELECT id,
       user_id,
       item_id,
       payment_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "purchase_order"
WHERE id = $1
LIMIT 1
`

func (q *Queries) FindPurchaseOrder(ctx context.Context, id uuid.UUID) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, findPurchaseOrder, id)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.PaymentID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPurchaseOrderByDealForUpdate = `-- name: FindPurchaseOrderByDealForUpdate :one
SELECT id,
       user_id,
       item_id,
       payment_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "purchase_order"
WHERE deal_id = $1
LIMIT 1 FOR UPDATE
`

func (q *Queries) FindPurchaseOrderByDealForUpdate(ctx context.Context, dealID uuid.NullUUID) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, findPurchaseOrderByDealForUpdate, dealID)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.PaymentID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPurchaseOrderByPaymentForUpdate = `-- name: FindPurchaseOrderByPaymentForUpdate :one
SELECT id,
       user_id,
       item_id,
       payment_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "purchase_order"
WHERE payment_id = $1
LIMIT 1 FOR UPDATE
`

func (q *Queries) FindPurchaseOrderByPaymentForUpdate(ctx context.Context, paymentID uuid.NullUUID) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, findPurchaseOrderByPaymentForUpdate, paymentID)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.PaymentID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPurchaseOrderForDeal = `-- name: FindPurchaseOrderForDeal :one
SELECT id,
       user_id,
       item_id,
       payment_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "purchase_order"
WHERE item_id = $1
  AND price <= $2
ORDER BY price DESC
LIMIT 1 FOR UPDATE
`

type FindPurchaseOrderForDealParams struct {
	ItemID uuid.UUID
	Price  float64
}

func (q *Queries) FindPurchaseOrderForDeal(ctx context.Context, arg FindPurchaseOrderForDealParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, findPurchaseOrderForDeal, arg.ItemID, arg.Price)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.PaymentID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPurchaseOrderForUpdate = `-- name: FindPurchaseOrderForUpdate :one
SELECT id,
       user_id,
       item_id,
       payment_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "purchase_order"
WHERE id = $1
LIMIT 1 FOR UPDATE
`

func (q *Queries) FindPurchaseOrderForUpdate(ctx context.Context, id uuid.UUID) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, findPurchaseOrderForUpdate, id)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.PaymentID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPurchaseOrdersByUser = `-- name: FindPurchaseOrdersByUser :many
SELECT id,
       user_id,
       item_id,
       payment_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "purchase_order"
WHERE id = $1
ORDER BY created_at DESC
`

func (q *Queries) FindPurchaseOrdersByUser(ctx context.Context, id uuid.UUID) ([]PurchaseOrder, error) {
	rows, err := q.db.Query(ctx, findPurchaseOrdersByUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PurchaseOrder
	for rows.Next() {
		var i PurchaseOrder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.PaymentID,
			&i.DealID,
			&i.Price,
			&i.Commission,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSellOrder = `-- name: FindSellOrder :one
SELECT id,
       user_id,
       item_id,
       accrual_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "sell_order"
WHERE id = $1
LIMIT 1
`

func (q *Queries) FindSellOrder(ctx context.Context, id uuid.UUID) (SellOrder, error) {
	row := q.db.QueryRow(ctx, findSellOrder, id)
	var i SellOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.AccrualID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSellOrderByAccrualForUpdate = `-- name: FindSellOrderByAccrualForUpdate :one
SELECT id,
       user_id,
       item_id,
       accrual_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "sell_order"
WHERE accrual_id = $1
LIMIT 1 FOR UPDATE
`

func (q *Queries) FindSellOrderByAccrualForUpdate(ctx context.Context, accrualID uuid.NullUUID) (SellOrder, error) {
	row := q.db.QueryRow(ctx, findSellOrderByAccrualForUpdate, accrualID)
	var i SellOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.AccrualID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSellOrderByDealForUpdate = `-- name: FindSellOrderByDealForUpdate :one
SELECT id,
       user_id,
       item_id,
       accrual_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "sell_order"
WHERE deal_id = $1
LIMIT 1 FOR UPDATE
`

func (q *Queries) FindSellOrderByDealForUpdate(ctx context.Context, dealID uuid.NullUUID) (SellOrder, error) {
	row := q.db.QueryRow(ctx, findSellOrderByDealForUpdate, dealID)
	var i SellOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.AccrualID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSellOrderForDeal = `-- name: FindSellOrderForDeal :one
SELECT id,
       user_id,
       item_id,
       accrual_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "sell_order"
WHERE item_id = $1
  AND price <= $2
ORDER BY price DESC
LIMIT 1 FOR UPDATE
`

type FindSellOrderForDealParams struct {
	ItemID uuid.UUID
	Price  float64
}

func (q *Queries) FindSellOrderForDeal(ctx context.Context, arg FindSellOrderForDealParams) (SellOrder, error) {
	row := q.db.QueryRow(ctx, findSellOrderForDeal, arg.ItemID, arg.Price)
	var i SellOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.AccrualID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSellOrderForUpdate = `-- name: FindSellOrderForUpdate :one
SELECT id,
       user_id,
       item_id,
       accrual_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "sell_order"
WHERE id = $1
LIMIT 1 FOR UPDATE
`

func (q *Queries) FindSellOrderForUpdate(ctx context.Context, id uuid.UUID) (SellOrder, error) {
	row := q.db.QueryRow(ctx, findSellOrderForUpdate, id)
	var i SellOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.AccrualID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSellOrdersByUser = `-- name: FindSellOrdersByUser :many
SELECT id,
       user_id,
       item_id,
       accrual_id,
       deal_id,
       price,
       commission,
       status,
       created_at,
       updated_at
FROM "sell_order"
WHERE id = $1
ORDER BY created_at DESC
`

func (q *Queries) FindSellOrdersByUser(ctx context.Context, id uuid.UUID) ([]SellOrder, error) {
	rows, err := q.db.Query(ctx, findSellOrdersByUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SellOrder
	for rows.Next() {
		var i SellOrder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.AccrualID,
			&i.DealID,
			&i.Price,
			&i.Commission,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePurchaseOrder = `-- name: UpdatePurchaseOrder :one
UPDATE "purchase_order"
SET status     = $2,
    payment_id = $3,
    deal_id    = $4,
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, item_id, payment_id, deal_id, price, commission, status, created_at, updated_at
`

type UpdatePurchaseOrderParams struct {
	ID        uuid.UUID
	Status    PurchaseStatus
	PaymentID uuid.NullUUID
	DealID    uuid.NullUUID
}

func (q *Queries) UpdatePurchaseOrder(ctx context.Context, arg UpdatePurchaseOrderParams) (PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, updatePurchaseOrder,
		arg.ID,
		arg.Status,
		arg.PaymentID,
		arg.DealID,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.PaymentID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSellOrder = `-- name: UpdateSellOrder :one
UPDATE "sell_order"
SET status     = $2,
    accrual_id = $3,
    deal_id    = $4,
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, item_id, accrual_id, deal_id, price, commission, status, created_at, updated_at
`

type UpdateSellOrderParams struct {
	ID        uuid.UUID
	Status    SellStatus
	AccrualID uuid.NullUUID
	DealID    uuid.NullUUID
}

func (q *Queries) UpdateSellOrder(ctx context.Context, arg UpdateSellOrderParams) (SellOrder, error) {
	row := q.db.QueryRow(ctx, updateSellOrder,
		arg.ID,
		arg.Status,
		arg.AccrualID,
		arg.DealID,
	)
	var i SellOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.AccrualID,
		&i.DealID,
		&i.Price,
		&i.Commission,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
